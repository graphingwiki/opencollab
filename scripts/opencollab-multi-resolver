#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
    @copyright: 2008 Lari Huttunen
    @license: MIT <http://www.opensource.org/licenses/mit-license.php>
"""
import re
import socket
import optparse
import subprocess
from subprocess import Popen
from opencollab.util.config import parse_config
from opencollab.wiki import CLIWiki
from opencollab.meta import Metas, Meta, Func
from opencollab.util.network import dns_blacklist, mr_attributes
from opencollab.util.regexp import *

def import_identities(collab,collab_metas,template,category,verbose):
    for page,pmeta in collab_metas.iteritems():
        if page:
            if category is not None:
                pmeta["category"].add(category)
            status = collab.setMeta(page,pmeta,template=template,replace=false)
            if verbose:
                print "Set meta for: " + repr(page) + "with status: " + repr(status)

def shred_triplets(resolved): 
    collab_metas = Metas()
    for triplet in resolved:
        if triplet:
            subj, pred, obj = triplet.split(';')
            if pred in mr_attributes:
                collab_metas[subj][pred].add(obj)
            else:
                collab_metas[subj][pred].add('[[%s]]' % obj)
    return collab_metas

def expand_ipv4(rr,new):
    new.append(rr + ";PTR")
    rev = re.split('\.', rr) 
    rev.reverse()
    new.append('.'.join(rev) + ".origin.asn.cymru.com;TXT")

def expand_as(rr,new):
    new.append(rr.upper() + ".asn.cymru.com;TXT")

def expand_name(rr,new):
    new.append(rr + ";A")
    new.append(rr + ";MX")
    new.append(rr + ";SOA")

def resolve_requests(expanded,mresolve):
    mr = Popen(mresolve, shell=True, stdin=subprocess.PIPE, 
        stdout=subprocess.PIPE, stderr=subprocess.PIPE, close_fds=1)
    for rr in expanded:
        mr.stdin.write(rr + '\n')
    (sout, err) = mr.communicate()
    return sout, err

def generate_requests(resolved,new):
    expanded = []
    rr_type = re.compile(';TYPE;')
    for triplet in new.split('\n'):
        if triplet:
            subj, pred, obj = triplet.split(';')
            if subj in dns_blacklist:
                continue
        if rr_type.search(triplet):
            if triplet not in resolved:
                try:
                    socket.inet_aton(subj)
                except socket.error:
                    if dns_re.search(subj):
                        expand_name(subj,expanded)
                    elif as_re.search(subj):
                        expand_as(subj,expanded)
                    else:
                        pass
                else:
                    expand_ipv4(subj,expanded)
        resolved.add(triplet)
    return expanded, resolved

def seed_initial(new): 
    expanded = []
    resolved = set([])
    for rr in new:
        try:
            socket.inet_aton(rr)
        except socket.error:
            if dns_re.search(rr):
                resolved.add(rr + ";TYPE;NAME")
                expand_name(rr,expanded)
            elif as_re.search(rr):
                resolved.add(rr.upper() + ";TYPE;AS")
                expand_as(rr,expanded)
            else:
                pass
        else:
            resolved.add(rr + ";TYPE;IPv4")
            expand_ipv4(rr,expanded)
    return expanded, resolved

def read_input():
    new = []
    for line in sys.stdin:
        new.append(line.strip())
    return new

def main():
    parser = optparse.OptionParser()
    parser.add_option( "-c", "--config",
        action="store",
        type="string", dest="config",
        metavar="CONFIG",
        help="CONFIG file path.")
    parser.add_option("-m", "--mresolve-path",
                      dest="mresolve_path",
                      default=None,
                      metavar="MRESOLVE-PATH",
                      help=("MRESOLVE-PATH. defaults to /usr/bin/mresolve."))
    parser.add_option("-r", "--recurse",
        action="store_true", dest="recurse", default=False,
        help="Perform queries recursively." )
    parser.add_option("-s", "--selection",
                      dest="selection",
                      default=None,
                      metavar="SEARCH",
                      help=("Use MetaTable SEARCH arguments to fetch input from a collab instead reading them from STDIN."))
    parser.add_option("-t", "--template",
                      dest="template",
                      default=None,
                      metavar="TEMPLATE",
                      help=("Optional TEMPLATE to use. Defaults to IdentityTemplate."))
    parser.add_option("-u", "--url",
                      dest="url",
                      default=None,
                      metavar="COLLAB-URL",
                      help=("COLLAB-URL to connect to."))
    parser.add_option("-w", "--wiki-category",
                      dest="category",
                      default=None,
                      metavar="CATEGORY",
                      help=("Optional CATEGORY to use, e.g. CategoryIdentity"))
    parser.add_option("-v", "--verbose",
        action="store_true", dest="verbose", default=False,
        help="Enable verbose output." )
    parser.set_usage("%prog [options]")
    options, args = parser.parse_args()
    new = []
    url=None
    mresolve_path="/usr/bin/mresolve"
    iopts={}
    collab_metas = Metas()
    types = set(("NAME", "IPv4", "AS"))
    if options.config:
        iopts = parse_config(options.config, "creds", "multi-resolver")
    if options.mresolve_path:
        mresolve_path=options.mresolve_path
    elif options.config and "mresolve_path" in iopts["multi-resolver"]:
        mresolve_path=iopts["multi-resolver"]["mresolve-path"]
    else:
        mresolve_path="/usr/bin/mresolve"
    if options.template:
        template=options.template
    elif options.config and "template" in iopts["multi-resolver"]:
        template=iopts["multi-resolver"]["template"]
    else:
        template="IdentityTemplate"
    if options.url:
        url = options.url
        collab = CLIWiki(url)
    elif options.config and "url" in iopts["creds"]:
        url = iopts["creds"]["url"]
        collab = CLIWiki(url, config=options.config)
    else:
        parser.error("Collab URL needs to be specified. Use -h for help.")
    if options.category:
        category=options.category
    elif options.config and "category" in iopts["multi-resolver"]:
        category=iopts["multi-resolver"]["category"]
    else:
        category=None
    if options.selection:
        selection = options.selection
    elif options.config and "selection" in iopts["multi-resolver"]:
        selection = iopts["multi-resolver"]["selection"]
    else:
        selection = None
    if selection is None:
        if options.verbose:
            print "Reading input identities from STDIN."
        new = read_input()
    else:
        if options.verbose:
            print "Fetching identities from collab."
        pages = collab.getMeta(selection)
        for page in pages:
            if pages[page]["TYPE"].single() in types:
                new.append(page)
            else:
                if options.verbose:
                    print page, " identity type is not supported."
    if not new:
        if options.verbose:
            print "No input identities, no work. Exiting."
        sys.exit()
    if options.verbose:
        print "Expanding initial requests."
    expanded,resolved = seed_initial(new)
    if options.recurse:
        if options.verbose:
            print "Resolving requests recursively."
        while expanded:
            new,err = resolve_requests(expanded,mresolve_path)
            if options.verbose:
                print err
            expanded,resolved = generate_requests(resolved,new)
    else:
        if options.verbose:
            print "Resolving requests."
        new,err = resolve_requests(expanded,mresolve_path)
        for triplet in new.split('\n'):
            resolved.add(triplet)
    if options.verbose:
        print "Shredding resolved RDF triplets."
    collab_metas.update(shred_triplets(resolved))
    if options.verbose:
        print "Importing resolved identities to: " + url
    import_identities(collab,collab_metas,template,category,options.verbose)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print "Script interrupted via CTRL-C."
