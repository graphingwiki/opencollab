#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
    opencollab-csv-meta
     - Edits or lists metadata on pages

    @copyright: 2011 by Juhani Eronen <exec@iki.fi> and Joachim Viide
    @license: MIT <http://www.opensource.org/licenses/mit-license.php>
"""
import csv
import sys
import socket
from optparse import OptionParser
from opencollab.wiki import CLIWiki
from opencollab.wiki import WikiFailure
from opencollab.util.config import parseOptions


def to_rows_default(pages):
    counts = {}
    for page, metas in pages.iteritems():
        for key, values in metas.iteritems():
            counts[key] = max(counts.get(key, 0), len(values))
    keys = sorted(counts.keys())

    keyrow = ["Page name"]
    for key in keys:
        keyrow.extend([key] * counts[key])
    yield keyrow

    for page in sorted(pages):
        metas = pages[page]
        row = [encode(page)]
        for key in keys:
            values = sorted(metas.get(key, []))
            row.extend(map(encode, values))
            row.extend([""] * (counts[key] - len(values)))
        yield row


def page_keys(pages):
    keys = set()
    for page, metas in pages.iteritems():
        for key, values in metas.iteritems():
            keys.add(key)
    return keys


def keyrow(keys):
    keys = sorted(keys)
    keyrow = ["Page name"]
    keyrow.extend(keys)
    return keyrow


def to_rows_aggregate(pages, separator):
    keys = page_keys(pages)
    yield keyrow(keys)

    for page in sorted(pages):
        metas = pages[page]
        row = [encode(page)]
        for key in keys:
            if key in metas:
                values = metas[key]
                stringified = encode(separator.join(values))
                row.extend([stringified])
            else:
                row.extend([""])
        yield row


def to_rows_multi_row(pages):
    keys = page_keys(pages)
    yield keyrow(keys)

    for page in sorted(pages):
        metas = pages[page]

        while True:
            content = False
            row = [encode(page)]

            for key in keys:
                if key in metas:
                    values = list(metas[key])
                    if len(values) > 0:
                        row.extend([encode(values.pop())])
                        content = True
                    metas[key] = values
                else:
                    row.extend([""])

            if content:
                yield row
            else:
                break


def encode(x):
    return x.encode("utf-8")


def decode(x):
    return x.decode("utf-8")


def escape(x):
    return x.encode("unicode-escape")


usage = "usage: %prog [options]"
parser = OptionParser(usage=usage)

parser.add_option("-G", "--get", type="string",
                  help=("Get metadata from Wiki with a  MetaTable argument " +
                        "string."))
parser.add_option("-A", "--add", type="string",
                  help=("Add metadata based on a semicolon-delimited CSV file " +
                        "in a batch fashion. First row states the keys, " +
                        "first colums states the pages."))
parser.add_option("-S", "--set", type="string",
                  help=("Replace metadata based on a semicolon-delimited CSV " +
                        "file in a batch fashion. First row states the keys, " +
                        "first colums states the pages."))
parser.add_option("--multivalues",
                  type="choice",
                  choices=["duplicate-keys", "aggregate-values", "multi-row"],
                  default="duplicate-keys",
                  help=("How to handle keys with multiple values:\n" +
                        "duplicate-keys: default, keys with multiple values get " +
                        "duplicate keys in the header for each instance of value.\n" +
                        "aggregate-keys: combine multivalues into a list for each row"
                        "multi-row: split multivalued keys into multiple rows, "
                        "by writing subsequent multivalues on each row until all"
                        "the values have been output"))
parser.add_option("--multivalue-separator", type="string", default="|",
                  help="Separator for multivalued data (aggregate-values)")

sect = "csv-meta"
ops = parseOptions(parser, sect, config=True, template=True)
x509 = ops[sect]["x509"]
x509_ca_file = ops[sect]["x509_ca_file"]
template = ops[sect]["template"]

while True:
    try:
        collab = CLIWiki(ssl_verify_cert=x509, ssl_ca_certs=x509_ca_file, **ops['creds'])

        if "get" in ops[sect]:
            query = ops[sect]["get"]
            if query:
                results = collab.getMeta(query)
                writer = csv.writer(sys.stdout, delimiter=";")

                if ops[sect]["multivalues"] == "duplicate-keys":
                    writer.writerows(to_rows_default(results))
                if ops[sect]["multivalues"] == "aggregate-values":
                    writer.writerows(to_rows_aggregate(results, ops[sect]["multivalue_separator"]))
                if ops[sect]["multivalues"] == "multi-row":
                    writer.writerows(to_rows_multi_row(results))

                sys.stdout.flush()

        if "set" in ops[sect]:
            filename = ops[sect]["set"]
            if filename:
                reader = csv.reader(open(filename, "rb"), delimiter=";")

                # Keys from first row, ignore the key for the first column
                keys = []
                for keys in reader:
                    keys = keys[1:]
                    break

                for row in reader:
                    if not row:
                        continue

                    page = decode(row[0])

                    metas = dict()
                    for key, value in zip(keys, row[1:]):
                        metas.setdefault(key, []).append(value)

                    result = collab.setMeta(page, metas, True, template)
                    for line in result:
                        print >> sys.stderr, escape(page) + ":", escape(line)

    except WikiFailure:
        print "ERROR: Authentication failed."
    except (UnicodeError, socket.gaierror):
        sys.exit("ERROR: Not a valid URL.")
    else:
        break
