#! /usr/bin/env python
# -*- coding: utf-8 -*-
"""
    The purpose of this script is to create an object oriented wiki image
    gallery utilizing a file system based image repository as a source.
    The path names are turned into categories, which classify a given
    image.

    @copyright: 2008 Lari Huttunen
    @license: MIT <http://www.opensource.org/licenses/mit-license.php>
"""
import os
import sys
import md5
import ConfigParser
from optparse import OptionParser
from PIL import Image
from PIL.ExifTags import TAGS
from opencollab.meta import Meta
from opencollab.wiki import GraphingWiki

def parse_config( cpath ):
    configparser = ConfigParser.ConfigParser()
    configparser.readfp( open(cpath) )
    creds = dict( configparser.items('creds') )
    uris = dict( configparser.items('dbs') )
    username = creds.pop("username")
    password = creds.pop("password")
    spath = uris.pop("spath")
    wiki = uris.pop("collab")
    return username, password, spath, wiki

def store_names( flist, dname, names ): 
    for name in names:
        flist.append( os.path.join( dname, name ) )

def scale_image( f, imeta ):
    """
    Aspect ratio calculation from:
    http://osdir.com/ml/python.image/2006-01/msg00010.html
    """
    maxw = 800
    maxtw = 128
    maxh = 600
    maxth = 128
    oaspect = float(maxw) / float(maxh)
    path, file = os.path.split(f)
    fname, ext = os.path.splitext(file)
    imeta["Filename"].add( file )
    try:
        img = Image.open( f )
        iaspect = float(img.size[0])/float(img.size[1])
        if iaspect >= oaspect:
           resimg = img.resize(( maxw , int(float(maxw/iaspect) + 0.5)), Image.ANTIALIAS) 
           resthumb = img.resize(( maxtw , int(float(maxtw/iaspect) + 0.5)), Image.ANTIALIAS) 
        else:
           resimg = img.resize(( int(float(maxh*iaspect) + 0.5), maxh), Image.ANTIALIAS) 
           resthumb = img.resize(( int(float(maxth*iaspect) + 0.5), maxth), Image.ANTIALIAS) 
        try:
            opath = "/tmp/"
            ofile = fname + ext
            othumb = fname + ".thumb.png"
            imeta["ofile"].add( opath + ofile )
            imeta["ofname"].add( ofile )
            imeta["image"].add( "attachment:" + ofile )
            imeta["othumb"].add( opath + othumb )
            imeta["otname"].add( othumb )
            imeta["shapefile"].add( "attachment:" + othumb )
            resimg.save( opath + ofile, img.format ) 
            resthumb.save( opath + othumb ) 
        except IOError:
            print "Temporary image save failed!"
            return False
        return True
    except IOError: 
        return False

def read_exif( f, imeta ):
    """
    PIL + exif reading from
    http://wolfram.kriesing.de/blog/index.php/2006/reading-out-exif-data-via-python
    This approach does not work, since the values are uninterpreted.
    """
    try:
        img = Image.open( f )
        info = img._getexif() 
        for tag, value in info.items():
            decoded = TAGS.get( tag, tag )
            imeta[tag].add( value )
    except IOError:
        pass

def upload_image( collab, pname, fn, fh, verbose ):
    for current, total in collab.putAttachmentChunked( pname, fn, fh ):
        percent = 100.0 * current / float(max(total, 1))
        status = current, total, percent
        if verbose:
            sys.stdout.write("\rsent %d/%d bytes (%.02f%%)" % status)
            sys.stdout.flush()
        if verbose:
            sys.stdout.write("\ndone\n")
            sys.stdout.flush()

def push_image( collab, imeta, verbose ):
    template = "PhotoTemplate"
    imeta["category"].add("CategoryPhoto")
    ofname = imeta.pop("ofname").single()
    ofile = imeta.pop("ofile").single()
    othumb = imeta.pop("othumb").single()
    otname = imeta.pop("otname").single()
    try:
        fh = file( ofile, 'rb' )
        pname = md5.new( fh.read() ).hexdigest()
    except IOError:
        raise
    status = collab.setMeta( pname, imeta, template=template, replace=True )
    if verbose:
        print status
    fh = file( ofile, 'rb' )
    upload_image( collab, pname, ofname, fh, verbose )
    fh = file( othumb, 'rb' )
    upload_image( collab, pname, otname, fh, verbose )

def main():
    usage = "usage: %prog [-v] -c CPATH"
    parser = OptionParser(usage=usage)
    parser.add_option( "-c", 
        action="store", type="string", dest="cpath",
        help="Config file path." )
    parser.add_option("-v", 
        action="store_true", dest="verbose", default=False,
        help="Enable verbose output." ) 
    ( options, args ) = parser.parse_args()
    if options.cpath:
        flist = []
        username, password, spath, wiki = parse_config( options.cpath )
        os.path.walk( spath, store_names, flist ) 
        collab = GraphingWiki( wiki, username=username, password=password  )
        for f in flist:
            imeta = Meta()
            image = scale_image( f, imeta )
            if image:
                #read_exif( f, imeta )
                push_image( collab, imeta, options.verbose )
    else:
        parser.error("Option -c is mandatory. Use -h for help.")

if __name__ == "__main__":
    main()

