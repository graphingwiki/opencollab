#! /usr/bin/env python
# -*- coding: utf-8 -*-
"""
    opencollab-push-tickets is an attempt to learn 
    roundup data retrieval for push semantics based 
    on a customer username or organisation name.

    @copyright: 2008-2010 Lari Huttunen
    @license: MIT <http://www.opensource.org/licenses/mit-license.php>
"""
import sys, socket, re, optparse, cStringIO, base64
import roundup
from roundup import instance
from opencollab.util.config import parseConfig
from opencollab.meta import Meta, Metas
from opencollab.util.config import parseOptions
from opencollab.wiki import CLIWiki, WikiFailure

def openDB(tpath):
    try:
        tracker = instance.open( tpath )
    except roundup.configuration.NoConfigError, e:
        sys.exit(e)
    else:
        db = tracker.open( "admin" )
        return db

def getUser(db, user):
    udata = Meta()
    unode = db.user.getnode(user)
    attr = ['username', 'realname', 'organisation', 'phone']
    for k in attr:
        udata[k].add(unode.get(k))
    return udata

def filterIssues(db, filter):
    issues = []
    mfilter = Meta()
    mfilter[filter] = filter
    mkey = mfilter[filter]
    for issue_id in db.issue.list(): 
        issue = db.issue.getnode(issue_id)
        customer = issue.get('customer')
        if customer:
            idata = Meta()
            idata.update(getUser(db, customer.pop()))
            username = idata['username']
            organisation = idata['organisation']
            if mkey in username or mkey in organisation:
                issues.append(issue_id)
    return issues

def getMessage(db, msg):
    message = Meta()
    # Message properties:
    # ['files', 'inreplyto', 'recipients', 'author', 'creation', 'actor',
    # 'summary', 'content', 'creator', 'messageid', 'date', 'activity',
    # 'type', 'id']
    msgobj = db.msg.getnode(msg)
    for f in msgobj.get('files'):
        message['file'].add('[[file%s]]' % f)
    for r in msgobj.get('recipients'):
        message['recipient'].add('[[user%s]]' % r)
    users = ['author', 'actor', 'creator']
    for u in users:
        user = msgobj.get(u)
        message[u].add('[[user%s]]' % user)
    strings = ['inreplyto', 'summary', 'messageid', 'type']
    for s in strings:
        string = msgobj.get(s)
        message[s].add(string)
    content = msgobj.get('content')
    message['content'].add('{{{\n%s\n}}}' % content)
    return message

def getFile(db, f):
    fileobj = Meta()
    # File properties:
    # ['name', 'creator', 'creation', 'actor', 'content', 'activity', 'type', 'id']
    fobj = db.file.getnode(f)
    content = fobj.get('content')
    fileobj['name'].add(fobj.get('name'))
    fileobj['type'].add(fobj.get('type'))
    fileobj['content'].add(base64.b64encode(content))
    attr = ['creator', 'actor']
    for u in attr:
        user = fobj.get(u)
        fileobj[u].add('[[%s]]' % user)
    return fileobj

def main():
    parser = optparse.OptionParser()
    parser.add_option("-f", "--filter",
                      dest="filter", default=None,
                      metavar="FILTER", help=("Organisation name or username to FILTER by."))
    parser.add_option("-n", "--tracker-name",
                      dest="tracker", default=None,
                      metavar="NAME", help=("Tracker NAME."))
    parser.add_option("-p", "--tracker-path",
                      dest="configpath", default=None,
                      metavar="PATH", help=("Tracker configuration directory PATH."))
    parser.set_usage("%prog [options]")
    userdata = Metas()
    issues = Metas()
    files = Metas()
    messages = Metas()
    sect = "push-tickets"
    ops = parseOptions(parser, sect, template=True) 
    url = ops["creds"]["url"]
    filter = ops[sect]["filter"]
    tracker = ops[sect]["tracker"]
    configpath = ops[sect]["configpath"]
    while True:
        try:
            collab = CLIWiki(**ops['creds'])
        except WikiFailure:
            print "ERROR: Authentication failed."
        except (UnicodeError, socket.gaierror):
            sys.exit("ERROR: Not a valid URL.")
        else:
            break
    if filter is None:
        parser.error("Use -f or --filter to select issues by customer organisation or username.")
    if configpath is not None:
        # DB classes:
        # "status", "timelog", "keyword", "priority", "user", 
        # "file", "msg", "query", "issue"
        db = openDB(configpath)
        issueids = set(filterIssues(db, filter))
        for id in issueids:
            # Issue properties:
            # ['customer', 'status', 'title', 'nosy', 'creation', 'messages', 
            # 'actor', 'times', 'priority', 'assignedto', 'topic', 'creator', 
            # 'activity', 'superseder', 'id', 'files']
            issue = db.issue.getnode(id)
            statuspage = "status" + issue.get("status")
            issues[id]["status"].add('[[%s]]' % statuspage)
            issues[id]["title"].add(issue.get("title"))
            #creation = issue.get("creation")
            #issues[id]["creation"].add(issue.get(creation))
            for msg in issue.get("messages"):
                issues[id]["message"].add('[[msg%s]]' % msg)
                messages[msg].update(getMessage(db, msg))
            priority = issue.get("priority")
            issues[id]["priority"].add('[[priority%s]]' % priority)
            for file in issue.get("files"):
                issues[id]["file"].add('[[file%s]]' % file)
                files[file].update(getFile(db, file))
            # User properties:
            #['username', 'creation', 'alternate_addresses', 'realname', 'roles', 
            # 'creator', 'organisation', 'address', 'actor', 'phone', 'activity', 
            # 'queries', 'timezone', 'password', 'id']
            attr = ['customer', 'actor', 'assignedto', 'creator']
            for a in attr:
                uid = issue.get(a)
                try:
                    userid = uid.pop()
                except AttributeError:
                    userid = uid
                except IndexError:
                    continue
                userpage = "user" + userid
                issues[id][a].add('[[%s]]' % userpage)
                userdata[userpage].update(getUser(db, userid))
            nosy = issue.get('nosy')
            for userid in nosy:
                userpage = "user" + userid
                issues[id]["nosy"].add('[[%s]]' % userpage)
                userdata[userpage].update(getUser(db, userid))
        db.close()
    else:
        parser.error(" Use -p or --tracker-path to specify the tracker configuration path.")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print "Script interrupted via CTRL-C."
