#! /usr/bin/env python
# -*- coding: utf-8 -*-
"""
    opencollab-push-tickets is an attempt to learn 
    roundup data retrieval for push semantics based 
    on a customer username or organisation name.

    @copyright: 2008-2010 Lari Huttunen
    @license: MIT <http://www.opensource.org/licenses/mit-license.php>
"""
import sys, socket, re, optparse, cStringIO
import roundup
from roundup import instance
from opencollab.util.config import parseConfig
from opencollab.meta import Meta, Metas
from opencollab.util.config import parseOptions
from opencollab.wiki import CLIWiki, WikiFailure

def openDB(tpath):
    try:
        tracker = instance.open( tpath )
    except roundup.configuration.NoConfigError, e:
        sys.exit(e)
    else:
        db = tracker.open( "admin" )
        return db

def getUser(db, user):
    #['username', 'creation', 'alternate_addresses', 'realname', 'roles', 
    # 'creator', 'organisation', 'address', 'actor', 'phone', 'activity', 
    # 'queries', 'timezone', 'password', 'id']
    udata = Meta()
    unode = db.user.getnode(user)
    attr = ['username', 'realname', 'organisation', 'phone', 'id']
    for k in attr:
        udata[k].add(unode.get(k))
    return udata

def filterIssues(db, filter):
    issues = []
    mfilter = Meta()
    mfilter[filter] = filter
    mkey = mfilter[filter]
    # DB classes:
    # "status", "timelog", "keyword", "priority", "user", 
    # "file", "msg", "query", "issue"
    for issue_id in db.issue.list(): 
        # ['customer', 'status', 'title', 'nosy', 'creation', 'messages', 
        # 'actor', 'times', 'priority', 'assignedto', 'topic', 'creator', 
        # 'activity', 'superseder', 'id', 'files']
        issue = db.issue.getnode(issue_id)
        customer = issue.get('customer')
        if customer:
            idata = Meta()
            idata.update(getUser(db, customer.pop()))
            username = idata['username']
            organisation = idata['organisation']
            if mkey in username or mkey in organisation:
                issues.append(issue_id)
    return issues

def main():
    parser = optparse.OptionParser()
    parser.add_option("-f", "--filter",
                      dest="filter", default=None,
                      metavar="FILTER", help=("Organisation name or username to FILTER by."))
    parser.add_option("-n", "--tracker-name",
                      dest="tracker", default=None,
                      metavar="NAME", help=("Tracker NAME."))
    parser.add_option("-p", "--tracker-path",
                      dest="configpath", default=None,
                      metavar="PATH", help=("Tracker configuration directory PATH."))
    parser.set_usage("%prog [options]")
    sect = "push-tickets"
    ops = parseOptions(parser, sect, template=True) 
    url = ops["creds"]["url"]
    filter = ops[sect]["filter"]
    tracker = ops[sect]["tracker"]
    configpath = ops[sect]["configpath"]
    while True:
        try:
            collab = CLIWiki(**ops['creds'])
        except WikiFailure:
            print "ERROR: Authentication failed."
        except (UnicodeError, socket.gaierror):
            sys.exit("ERROR: Not a valid URL.")
        else:
            break
    if filter is None:
        parser.error("Use -f or --filter to select issues by customer organisation or username.")
    if configpath is not None:
        db = openDB(configpath)
        issueids = set(filterIssues(db, filter))
        print issueids
        db.close()
    else:
        parser.error(" Use -p or --tracker-path to specify the tracker configuration path.")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print "Script interrupted via CTRL-C."
