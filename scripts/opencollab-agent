#! /usr/bin/env python
# -*- coding: utf-8 -*-
"""
    @copyright: 2008 by Joachim Viide
    @license: MIT <http://www.opensource.org/licenses/mit-license.php>
"""

import os
import sys
import time
import socket
import signal
import pickle
import random
import select

from opencollab.meta import Meta
from opencollab.wiki import CLIWiki, WikiFailure

def processIsAlive(processId):
    try:
        pid, status = os.waitpid(processId, os.WNOHANG)
    except os.error:
        return False
    return pid != processId

def execute(page, script, keys):
    locals = dict()

    exec script in locals

    func = locals.get("execute")
    return func(page, **keys)

def readData(*fds):
    datas = list()
    readable, _, _ = select.select(fds, [], [], 0)

    for index, fd in enumerate(fds):
        if fd in readable:
            datas.append(os.read(fd, 1024**2))
        else:
            datas.append("")
 
    return datas

def runOneTask(agentId, wiki, interval=10.0, dieAfter=10*60.0):
    while True:
        print "Fetching a new task"
        try:
            newTask = wiki.request("TaskServer", agentId, "get")
        except WikiFailure, msg:
            print "Wiki failure:", msg
        else:
            if newTask:
                break
            print "No new task found"

        time.sleep(interval)

    page, metas, lang, script = newTask
    print "Got task '%s'" % page
    print " lang: %s" % lang
    print " metas: %s" % repr(metas)

    resultReadFd, resultWriteFd = os.pipe()
    outReadFd, outWriteFd = os.pipe()
    errReadFd, errWriteFd = os.pipe()

    pid = os.fork()
    if pid == 0:
        os.close(resultReadFd)
        os.close(outReadFd)
        os.close(errReadFd)
        
        # Redirect stdout
        os.dup2(outWriteFd, 1)
        os.close(outWriteFd)

        # Redirect stderr
        os.dup2(errWriteFd, 2)
        os.close(errWriteFd)

        result = execute(page, script, metas)
        os.write(resultWriteFd, pickle.dumps(result))
        
        os.close(resultWriteFd)
        os._exit(0)

    os.close(outWriteFd)
    os.close(errWriteFd)
    os.close(resultWriteFd)

    outData = ""
    errData = ""

    pollInterval = 1.0
    lastHeartBeat = checkpoint = time.time()

    try:
        while True:
            # Read data from stdout and stderr of the child process
            newOutData, newErrData = readData(outReadFd, errReadFd)
            
            sys.stdout.write(newOutData)
            sys.stdout.flush()
            outData += newOutData
            
            sys.stderr.write(newErrData)
            sys.stderr.flush()
            errData += newErrData
            
            status = outData, errData

            # Perform ending rituals if neede
            if not processIsAlive(pid):
                reader = os.fdopen(resultReadFd, "rb")
                data = reader.read()
                reader.close()

                os.close(outReadFd)
                os.close(errReadFd)

                try:
                    try:
                        result = pickle.loads(data)
                    except EOFError:
                        print "Task failed"
                        result = dict(status=["failed"])
                        wiki.request("TaskServer", agentId, "change", page, status, result)
                    else:
                        print "Got result %s" % repr(result)
                        wiki.request("TaskServer", agentId, "close", page, status, result)
                except WikiFailure, msg:
                    print "Wiki failure:", msg
                else:
                    print "Sent result"

                break

            # Send out a heartbeat if needed
            if time.time()-lastHeartBeat >= interval:
                socket.setdefaulttimeout(2 * interval)
                try:
                    try:
                        print " ...heartbeat..."
                        wiki.request("TaskServer", agentId, "change", page, status)
                    except WikiFailure, msg:
                        print "Wiki failure:", msg
                    else:
                        checkpoint = time.time()
                finally:
                    socket.setdefaulttimeout(None)
                lastHeartBeat = time.time()

            # Quit if we haven't been able to send a heartbeat
            # for a longish time.            
            if time.time()-checkpoint >= dieAfter:
                print "Grace perioid ended, quitting"
                break

            time.sleep(pollInterval)
    finally:
        # Kill the child process
        try:
            os.kill(pid, signal.SIGINT)
        except OSError:
            pass

        while processIsAlive(pid):
            time.sleep(pollInterval)

        print "Task ended"

def main():
    import optparse

    parser = optparse.OptionParser()
    parser.add_option("-n", "--name",
                      dest="name",
                      default=None,
                      metavar="NAME",
                      help="force the agent's name to NAME")
    parser.add_option("-c", "--config",
                      dest="config",
                      default=None,
                      metavar="CONFIG",
                      help=("read the username and password from the "+
                            "config file CONFIG"))
    options, args = parser.parse_args()

    url = ''
    if args:
        url = args[0]
    wiki = CLIWiki(url, config=options.config)

    name = options.name
    if name is None:
        name = socket.gethostbyname(socket.gethostname())
    name += "-%d" % random.randint(0, 2**32)

    print "Getting tasks from %s as agent %s" % (url, name)

    while True:
        runOneTask(name, wiki)

if __name__ == "__main__":
    main()
