#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
    @copyright: 2008 Marko Laakso, Mika Sepp√§nen, Lari Huttunen
    @license: MIT <http://www.opensource.org/licenses/mit-license.php>
"""
import os, sys, re, string, optparse
from xml.dom import minidom
from opencollab.wiki import CLIWiki, WikiFailure
from opencollab.meta import Meta
from opencollab.util.config import parseOptions
from opencollab.util.file import hashFile, uploadFile
from opencollab.util.wiki import getPages
from gzip import GzipFile

def getText(nodelist):
    rc = ""
    for node in nodelist:
        if node.nodeType == node.TEXT_NODE:
            rc = rc + node.data
    return rc

def parse_summary(dir, file='summary.xml'):
    summary_metas = Meta()
    xmldoc = minidom.parse(os.path.join(dir, file))
    for fact in xmldoc.getElementsByTagName("fact"):
        label = fact.getAttribute("label")
        if label:
            summary_metas[label].add(getText(fact.childNodes))
    for collection in xmldoc.getElementsByTagName("collection"):
        label = collection.getAttribute("label")
        for cfact in collection.getElementsByTagName("fact"):
            summary_metas[label].add(getText(cfact.childNodes))
    return summary_metas

def parse_tool_options(page_metas):
    options=[]
    tmp=[]
    option_metas = Meta()
    for opt in page_metas["Options"]:
        tmp.append(opt)
    opt_str = str(tmp.pop())
    options = opt_str.split('--')
    for opt in options:
        tmp = opt.split()
        if(tmp):
            opt_key = "Option "
            opt_key = opt_key + " ".join(tmp[0:1])
            opt_value = " ".join(tmp[1:])
            option_metas[opt_key].add(opt_value)
    return option_metas

def parse_notes(dir, file='notes.xml'):
    note_metas = Meta()
    xmldoc = minidom.parse(os.path.join(dir, file))
    for value in xmldoc.getElementsByTagName('value'):
        key = value.getAttribute('key')
        description = value.getAttribute('description')
        text_value = getText(value.childNodes)
        note_metas[key].add(text_value)
        kd = key + " Description"
        note_metas[kd].add(description)
    return note_metas

def handle_paths(collab, testplan_page, dirs, verbose):
    at = re.compile('@')
    flist=[]
    page_metas=Meta()
    template = "TestRunTemplate"
    page_metas["category"].add("CategoryTestRun")
    for dir in dirs:
        flist = os.listdir(dir)
        if 'summary.xml' in flist:
            print "Handling directory: " + dir
            page_metas.update(parse_summary(dir))
            fpath = os.path.join(dir, 'summary.xml')
            page_metas["Summary XML"].add('[[attachment:summary.xml]]')
            testrun_page = hashFile(fpath)
            uploadFile(collab, testrun_page, fpath, 'summary.xml')
            page_metas.update(parse_tool_options(page_metas))
            if('main.log.gz' in flist):
                pass
            if('main.log' in flist):
                page_metas["Main Log"].add('[[attachment:main.log.gz]]')
                if('main.log.gz' in flist):
                    pass
                else:
                    gzipped = GzipFile(os.path.join(dir, "main.log.gz"), "w")
                    gzipped.write(open(os.path.join(dir, "main.log")).read())
                    gzipped.close()
                uploadFile(collab,testrun_page, os.path.join(dir, 'main.log.gz'), 'main.log.gz')
            if('run.set' in flist):
                page_metas["Settings"].add('[[attachment:run.set]]')
                uploadFile(collab, testrun_page, os.path.join(dir, 'run.set'), 'run.set')
            if('runinfo' in flist):
                page_metas["Settings"].add('[[attachment:runinfo]]')
                uploadFile(collab, testrun_page, os.path.join(dir, 'runinfo'), 'runinfo')
            if('statistics.csv' in flist):
                page_metas["Statistics"].add('[[attachment:statistics.csv]]')
                uploadFile(collab,testrun_page, os.path.join(dir, 'statistics.csv'), 'statistics.csv')
            if('summary.txt' in flist):
                page_metas["Summary"].add('{{attachment:summary.txt}}')
                uploadFile(collab, testrun_page, os.path.join(dir, 'summary.txt'), 'summary.txt')
            if 'notes.xml' in flist:
                page_metas["Notes"].add('[[attachment:notes.xml]]')
                page_metas.update(parse_notes(dir))
                uploadFile(collab, testrun_page, os.path.join(dir, 'notes.xml'), 'notes.xml')
            if(testplan_page is not None):
                if(at.search(testplan_page)):
                    tmp = at.sub('', testplan_page) 
                    for page in page_metas[tmp]:
                        page_metas["Test Plan"].add('[[%s]]' % page)
                else:
                    page_metas["Test Plan"].add('[[%s]]' % testplan_page)
            status = collab.setMeta(testrun_page, page_metas, template=template, replace=True)
            if verbose:
                print testrun_page, status
            page_metas=Meta()
            page_metas["category"].add("CategoryTestRun")

def walk_dirs(path):
    dlist=[]
    for root, dirs, files in os.walk(path):
        for dir in dirs:
           dlist.append(os.path.join(root,dir)) 
    return dlist

def main():
    parser = optparse.OptionParser()
    parser.add_option("-n", "--testplan-page-name", action="store",
        type="string", dest="testplan", default=None,
        metavar="TESTPLAN-PAGE", help="Specify a TESTPLAN-PAGE name to link the test runs to." )
    parser.add_option("-p", "--prompt", action="store_true", 
        dest="prompt", default=False,
        help="Prompt for selecting the test plan from search results obtained via -s.")
    parser.add_option("-s", "--search-string",
        action="store", type="string", dest="search", default=None,
        metavar="SEARCH-STRING", help="MetaTable SEARCH-STRING." )
    parser.add_option("-r", action="store_true", dest="recursive", default=False,
        help="Enable recursion on input directories.")
    parser.set_usage("%prog [options] <1..N input directories>")
    dlist=[]
    sect = "defensics"
    ops = {}
    ops = parseOptions(parser, sect, template=True)
    url = ops["creds"]["url"]
    verbose = ops[sect]["verbose"]
    dlist = ops[sect]["args"]
    if len(dlist) < 1:
        parser.error("You must supply 1..N input directories. Use -h for help.")
    search_string = ops[sect]["search"]
    testplan_page = ops[sect]["testplan"]
    if verbose:
        print "Authenticating to: " + repr(url)
    while True:
        try:
            collab = CLIWiki(**ops['creds'])
        except WikiFailure:
            print "ERROR: Authentication failed."
        except (UnicodeError, socket.gaierror):
            sys.exit("ERROR: Not a valid URL.")
        else:
            break
    if search_string is not None:
        if not re.search(search_string,'\|\|.*\|\|'):
            search_string += ',|| ||'
        tpages = getPages(collab, search_string)
        nro = 0
        for page in tpages:
            msg = ""
            msg += "%3d %s" % (nro, page)
            for metakey,metavalue in tpages[page].iteritems():
                msg += " %s:%s" % (metakey,"/".join(metavalue))
            print "%s" % msg
            nro += 1
        if ops[sect]["prompt"]:
            nro -= 1
            cont = True
            pnames = tpages.items()
            while cont:
                print "Enter your selection or q to quit: " 
                tmp = sys.stdin.readline().strip()
                if(tmp == "q"):
                    sys.exit()
                try:
                    answer = int(tmp)
                except ValueError:
                    print "Your selection must be between 0 and ", nro
                else:
                    if((answer >= 0) and (answer <= nro)):
                        testplan_page = pnames[answer][0]
                        cont = False
                    else:
                        print "Your selection must be between 0 and ", nro
    if ops[sect]["recursive"]:
        if(verbose):
            print "Walking ", dlist
        new_dl=[]
        for dir in dlist:
            new_dl.append(dir)
            new_dl = (walk_dirs(dir))
        a = set(new_dl)
        b = set(dlist)
        dirs = a | b 
    else:
        dirs = set(dlist)
    if(verbose):
        print "Handling: ", dirs
    handle_paths(collab, testplan_page, dirs, verbose)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print "Script interrupted via CTRL-C."

